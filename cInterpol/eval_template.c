// Generated from Mako template: eval_template.c
// DO NOT EDIT THIS FILE MANUALLY
#include <math.h>
//#include <stdio.h>
%if SIZE_T == 'size_t':
#include <stdlib.h> /* size_t */
%endif
#include "newton_interval.h"
#include "eval.h"

%for token in tokens:
%for wy in range(max_wy):
%for i in range(max_deriv+1)

static double ${token}_scalar_${wy}_${i}(
    const double t, const double const * c)
{
% for cse_token, cse_def in coeff_cses[token]:
    double ${cse_token} = ${cse_def};
% endfor
    return ${eval_scalar_expr[token][wy][i]};
}

void ${token}_eval_${wy}_${i}(const ${SIZE_T} nt,
			 const double * const restrict t,
			 const double * const restrict c,
			 const ${SIZE_T} nout,
			 const double * const restrict tout, 
			 double * const restrict yout,
			 ){
    // derivative = 0 evaluates function value, 1 evaluates first
    // derivative and so on..
    ${SIZE_T} ti = nt; // max: nt-1, nt considered "uninitialized"

#pragma omp parallel for firstprivate(ti) schedule(static)
    for (${SIZE_T} oi=0; oi<nout; ++oi){
	// Set ti
	if (ti == nt){ // ti == nt considered uninitialized!
	    ti = get_interval(t, nt, tout[oi]);
	    if (ti == -1)
		ti = 0;
	}
	else{
	    ti = get_interval_from_guess(t, nt, tout[oi], ti);
	    if (ti == -1)
		ti = 0;
	}

	// Calculate value of yout[oi] at tout[oi]
	// for shifted coefficients.
	yout[oi] = ${token}_scalar_${wy}_${i}(tout[oi]-t[ti], c+oi*${wy});
	}
    }
}
%endfor
%endfor
%endfor
